# 정규표현식

## preview

프로그래머스 문제를 풀다가 정규표현식을 사용하게 되면 코드를 엄청나게 줄일 수 있다는 것을 알게 되었다. 정규표현식은

- 각각 다른 포맷으로 저장된 데이터를 추출해야 할 때, (전화번호, 이메일 ,ip 주소 등등)
- 코드에서 특정 변수의 이름을 치환하고 싶지만 해당 변수의 이름을 포함하고 있는 함수는 제외하고 싶을 때,
- 특정 조건과 위치에 따라서 문자열에 포함된 공백이나 특수문자를 제거하고 싶을 때

등 **검색**과 **치환**이라는 두 개의 카테고리에서 사용된다.

---

## 생성하기

정규표현식에서는 리터럴방식과 정규식생성자생성방식의 두 가지 방식이 있는데 스크립트가 로드 될 때 컴파일되므로 정규식 문자열이 변하지 않는다면 리터럴 방식으로 선언하는 것이 성능상의 이점이 있다고 한다. 생성자 생성 방식은 정규식을 동적으로 변화시켜야 할 때 유용하다.(동적으로 변화시키는것이 뭔지는 잘 모르겠다.)

`const regex = /abc/` 리터럴 선언 방식

`const regex = new RegExp('abc')` 생성자 생성 방식

---

## 이스케이프

백슬래시(\)를 사용하면 특수문자를 문자 그대로 해석할 수 있게 해준다. 정규표현식에서의 특수문자는 특수한 용도로 사용되는 예약어이기 때문에 \를 사용하지 않는다면 기대했던 결과와 다른 결과를 출력할 수 있다.

---

## 플래그

```jsx
const 리터럴 = /string/flag
const 생성자 = new Regex(/string/, flag)
```

`/string/g` : 전역검색, g가 붙지 않으면 최초 검색 결과만 반환을 하지만 g가 붙으면 모든 검색 결과를 배열로 반환한다.

`/string/m` : 줄바꿈 검색, 각 줄별로 대응된다.

`/string/i` : 대소문자 구분 없음

---

## 메타 문자

### 문자그룹

`[]` , `[^]`

대괄호로 묶인 문자 그룹은 대괄호 내부의 문자열 중 하나라도 일치하는 경우를 의미한다. 이 때 대괄호 안에 들어가는 특수문자는 따로 이스케이프 처리를 해주지 않아도 된다.

대괄호 안에서 '-'(대시)를 이용한다면 보다 간단하게 표시 할 수 있다.

`ex) [A-Z] === [ABCDEFGHIJKLMNOPQRSTUVWXYZ]`

대괄호 안에서의 ^기호는 NOT을 의미한다.

`ex) [^A] === [BCDEFGHIJKLMNOPQRSTUVWXYZ]` (A만 제외하고 결과값 출력)

**10진수문자** : `/d`, `/D` [0-9] (대문자는 역집합)

**단어 문자** : `/w`, `/W` [a-z, A-Z](대문자는 역집합)

**공백 문자** : `/s`, `/S` ['',' '](대문자는 역집합)

### 앵커

`^`, `$`

앵커는 입력된 정규식이 어떤 특정 위치에서 동작할지를 제한하는 역할의 문자이다. 위치만 제한하고 검색 결과에는 포함되지 않는다.

패턴 시작 앵커(^)는 해당 정규식이 줄의 시작부분인지를 확인하는 역할을 하고, 보통 정규식의 가장 앞에 붙여서 사용한다.

패턴 종료 앵커($)는 해당 정규식이 줄의 마지막 부분인지를 확인하는 역할을 하고, 보통 정규식의 가장 마지막에 붙여서 사용한다.

이 때, []안에 있는 ^와는 다른 용법임을 주의해야 한다.

### 210831 추가

인라인으로 적용된 스타일 속성을 정규표현식을 사용해 지워야 하는 상황이었다.

```jsx
replace(style="[^"]+",'')
```

'style="'까지의 스트링을 처리하고 뒤에 속성들은 []로 묶어 처리한 후에 마지막 "를 추가해 정규표현식을 설정했다.
