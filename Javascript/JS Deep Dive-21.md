# 빌트인 객체

---

### JS 객체의 비교

js 객체는 크게 3개의 객체로 분류된다.

- 표준 빌트인 객체

    ```jsx
    표준 빌트인 객체는 ECMAscript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통기능을 제공한다.
    표준 빌트인 객체는 ECMAscirpt 사양에 정의된 객체이므로 자바스크립트 실행환경과 관계없이 언제나 사용 할 수 있다.
    표준 빌트인 객체는 전역 객체의 프로퍼티로 제공된다.
    ```

- 호스트 객체

    ```jsx
    호스트 객체는 ECMAscript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체를 말한다.
    ```

- 사용자 정의 객체

    ```jsx
    사용자 정의 객체는 표준 빌트인 객체와 호스트 객체처럼 기본 제공 되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다.
    ```

21챕터에서는 이 세가지의 객체 중 표준 빌트인 객체에 관해 다룬다. js는 40여개의 표준 빌트인 객체를 제공하는데, `Math`, `Reflect`, `JSON`을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만 제공한다. 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만 제공한다.

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토 타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객체다.

---

### 원시값과 래퍼 객체

String, Number, Boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유 → 원시값에 대해 마치 객체처럼 마침표 표기법으로 접근하면 js 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 이렇게 원시 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 **래퍼 객체**라고 한다. (ex. stirng.length 등) 이 래퍼 객체의 처리가 종료되면, 래퍼객체는 가비지 컬렉션의 대상이 된다. 

```jsx
//예제
const str = 'hello'
str.name = 'Kim'
console.log(str.name)//?
```

Number나 Boolean에서도 마찬가지의 결과를 가지지만 Boolean 값으로 메소드를 호출하는 경우는 없다.

String, Number, Boolean은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용할 수 있으며, 표준 빌트인 객체의 프로토타입 메소드 및 프로퍼티를 참조할 수 있다. 따라서 String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 인스턴스를 생성할 필요가 없으며 권장되지도 않는다. 

---

### 전역 객체

전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며, 어떤 객체에도 속하지 않은 최상위 객체이다. 라고 저자는 정의내린다. 브라우저 환경에서는 전역객체로 window를 가리키게 되고 node.js 환경에서는 global이 전역객체를 가리키게 된다.

전역객체는 표준 빌트인 객체와 환경에 따른 호스트 객체 그리고 var로 선언한 전역 변수, 전역 함수를 프로퍼티로 갖는다. 

전역 객체는 개발자가 의도적으로 생성할 수 없으며, 전역 객체의 프로퍼티를 참조할 때 window(global)를 생략할 수 있다.

```jsx
window.parseInt('F',16)  === parseInt('F' , 16) // true (15)
```

let과 const 키워드로 선언한 전역 변수는 보이지 않는 블록내에 존재하게 되어 전역변수로 처리되지 않는다.
